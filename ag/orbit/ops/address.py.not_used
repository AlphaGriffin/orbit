# Copyright (C) 2018 Alpha Griffin
# @%@~LICENSE~@%@

from . import Abstract

from bitcash.format import public_key_to_address, verify_sig


class Address(Abstract):

    CHARS_ADDRESS_MIN = 15
    CHARS_ADDRESS_MAX = 60
    BYTES_PUBKEY_MIN = 10
    BYTES_PUBKEY_MAX = 80
    BYTES_SIG_MIN = 10
    BYTES_SIG_MAX = 80

    def __init__(self, token_address, public_key, signature):
        self.validate_range('Address length', len(token_address), self.CHARS_ADDRESS_MIN, self.CHARS_ADDRESS_MAX)
        self.validate_range('Public key length', len(public_key), self.BYTES_PUBKEY_MIN, self.BYTES_PUBKEY_MAX)
        self.validate_range('Signature length', len(signature), self.BYTES_SIG_MIN, self.BYTES_SIG_MAX)

        if not token_address.startswith('bitcoincash:'):
            raise ValueError('Address must be a \'bitcoincash:\' type')

        self.user = public_key_to_address(public_key)
        self.token = token_address
        self.pubkey = public_key
        self.sig = signature

    def __str__(self, indent=None):
        return self.to_string(indent=indent, user_address=self.user, token_address=self.token,
                public_key=self.pubkey, signature=self.sig)

    def prepare(self):
        address = self.token[12:].encode('ascii')

        message = (len(address).to_bytes(1, self.ENDIAN) + address + 
                len(self.pubkey).to_bytes(1, self.ENDIAN) + self.pubkey +
                len(self.sig).to_bytes(1, self.ENDIAN) + self.sig)

        return message

    def verify(self):
        return verify_sig(self.sig, self.token[12:].encode('ascii'), self.pubkey)

    @classmethod
    def sign(cls, wallet, token_address):
        if not token_address.startswith('bitcoincash:'):
            raise ValueError('Address must be a \'bitcoincash:\' type')

        return wallet.sign(token_address[12:].encode('ascii'))

    @classmethod
    def parse(cls, data):
        if len(data) < 1:
            raise ValueError('Not enough data while reading address size')

        size = int.from_bytes(data[0:1], cls.ENDIAN)
        data = data[1:]

        token_address = 'bitcoincash:' + data[:size].decode('ascii')
        data = data[size:]

        if len(data) < 1:
            raise ValueError('Not enough data while reading public key size')

        size = int.from_bytes(data[0:1], cls.ENDIAN)
        data = data[1:]

        public_key = data[:size]
        data = data[size:]

        if len(data) < 1:
            raise ValueError('Not enough data while reading signature size')

        size = int.from_bytes(data[0:1], cls.ENDIAN)
        data = data[1:]

        signature = data[:size]
        data = data[size:]

        if len(data) > 0:
            raise ValueError('Extra data after reading all fields')

        return Address(token_address, public_key, signature)

